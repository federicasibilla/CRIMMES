"""
CR_to_LV.py: mapping steady state CR networks onto the corresponding LV pair-wise networks. 
             Assumes the networks to map are stored in a CSV file, with equilibrium values and parameters 
             Also assumes facultative, non regulated functions for the mapping

OUTPUTS a pickle file with     data = {
                                        'n_supplied': df['n_supplied'],
                                        'n_consumed': df['n_consumed'],
                                        'n_produced': df['n_produced'],
                                        'structure':  df['structure'],
                                        'leakage': df['leakage'],
                                        'parameters':param,
                                        'replica':df['replica'],
                                        'uptake':up_mat,
                                        'D':met_mat,
                                        'CR_R':R_fin[::200], # only save one every 10 time steps to make it lighter
                                        'CR_N':N_fin[::200], # only save one every 10 time steps to make it lighter
                                        'LV': solLV.y[:,::200],
                                        'g0':g_LV,
                                        'A':A_int
                                    }
        inside the dedicated Data folder

"""

import os
import sys
import pickle
import ast
from pathlib import Path

import pandas as pd
import numpy as np

path = os.path.splitext(os.path.abspath(__file__))[0]
base_path = path.split('/CRIMMES/MODEL')[0]
module_path = f'{base_path}/CRIMMES/MODEL/shared_scripts'
module_path_1 = f'{base_path}/CRIMMES/MODEL/shared_scripts/mapping'

# Add the directory to sys.path
if module_path not in sys.path:
    sys.path.append(module_path)
if module_path_1 not in sys.path:
    sys.path.append(module_path_1)

import N_dynamics
import R_dynamics
import update
import well_mixed
import mapping_F as mapping

from scipy.integrate import solve_ivp

#----------------------------------------------------------------------------------------------------------------------
# import dataframe of the networks to map, as an example here we import the ones from the protocol_1 generation
# ATT, the script might have to change a bit if the csv file comes from a different protocol, in the data saving and in the 
# structure of the parameters passing
# Construct the full path of the pickle file
pickle_file_path = Path('Path to pickle file generated by the protocol_1 notebook')

df = pd.read_pickle(pickle_file_path)
#----------------------------------------------------------------------------------------------------------------------

def map_network(i):

    """
    i: int, index in the dataframe of the network to map

    """

    # create paths to save results
    # create paths to save results, these are examples, ad they will end up in the Data folder
    path = f'{base_path}/CRIMMES/MODEL/Data/CR_to_LV'
    results_dir = f"{path}_results/{i}"
    os.makedirs(results_dir, exist_ok=True)

    n_s=8

    # defining binary uptake matrix with 5 preferences for each species
    up_mat = df['C'][i][0]
    n_r=up_mat.shape[1]

    # defining sign matrix (all positive nutrients here)
    sign_mat = np.ones((n_s,n_r))

    # no essential nutrients (only catabolic cross-feeding)
    mat_ess = np.zeros((n_s,n_r))

    # no auxotrophies (anyone can produce what metabolism allows)
    spec_met = np.ones((n_s,n_r))

    # create metabolic matrix of sparcity 0. with entries sampled from Dirichelet distribution: everyone produces everything
    met_mat = df['D'][i][0]

    # recapitulate in dictionary
    mat = {
        'uptake'  : up_mat,
        'met'     : met_mat,
        'ess'     : mat_ess,
        'spec_met': spec_met,
        'sign'    : sign_mat
    }

    # definition of the rest of the model parameters

    # set dilution
    param = df['param_dict'][i]
    if isinstance(param, str):
        # Evaluate the string with numpy's array
        param = eval(param, {"array": np.array})
    param=param[0]

    # run CR model for 200000 steps 
    N_fin = df['N_cr'][i]
    R_fin = df['R_cr'][i][0]

    # calculate matrices for mapping
    grad_mat=mapping.grad_i_alpha(R_fin[-1,:],param,mat)
    sig=mapping.sigma(R_fin[-1,:],param)
    f_mat=mapping.f_i_alpha(R_fin[-1,:],param,mat)

    # intrinsic growth rates
    g_LV = np.zeros((n_s))
    for i in range(n_s):
        g_LV[i]=np.dot(grad_mat[i],sig)

    # interaction matrix
    A_int=np.zeros((n_s,n_s))
    for i in range(n_s):
        for j in range(n_s):
            A_int[i,j]=np.dot(grad_mat[i],f_mat[j])

    # Solve Lotka-Volterra dynamics with the calculated parameters
    lv_args = (g_LV,A_int,n_s)
    t_span_lv = (0,100000)
    t_eval_lv = np.arange(t_span_lv[0],t_span_lv[1],1)
    solLV = solve_ivp(fun=mapping.LV_model, t_span=t_span_lv, y0=np.ones((n_s)), t_eval=t_eval_lv, args=lv_args)

    # save results
    data = {
        'n_supplied': df['n_supplied'],
        'n_consumed': df['n_consumed'],
        'n_produced': df['n_produced'],
        'structure':  df['structure'],
        'leakage': df['leakage'],
        'parameters':param,
        'replica':df['replica'],
        'uptake':up_mat,
        'D':met_mat,
        'CR_R':R_fin, # only save one every 10 time steps to make it lighter
        'CR_N':N_fin, # only save one every 10 time steps to make it lighter
        'LV': solLV.y[:,::200],
        'g0':g_LV,
        'A':A_int
    }

    # output file path
    output_file = f'{results_dir}/all_data.pkl'

    # save as pickle
    with open(output_file, 'wb') as file:
        pickle.dump(data, file)

    return 

#------------------------------------------------------------------------------------------------------------

if __name__ == "__main__":
    
    # Check if there are command-line arguments
    if len(sys.argv) == 2:
        i = int(sys.argv[1])

        # Run the simulation with the provided parameters
        map_network(i)
        print(f"Simulation completed for row number {i}")

    else:
        print("Usage: python map_network.py")

